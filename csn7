#! /usr/bin/env lua

-- Copyright (c) 2024 <dev@brigid.jp>
-- This software is released under the MIT License.
-- https://opensource.org/licenses/mit-license.php

local brigid = require "brigid"
brigid.dlopen_self()

local unpack = table.unpack or unpack

----------------------------------------------------------------------

-- https://www.iana.org/assignments/media-types/media-types.xhtml
local media_types = {
  json = "application/json";
  urlencoded = "application/x-www-form-urlencoded";
}

----------------------------------------------------------------------

local function read_contents(path)
  local handle, message = io.open(path, "rb")
  if not handle then
    return handle, message
  end

  local contents = handle:read "*a"
  handle:close()
  return contents
end

local function read_json(path)
  local result , message = read_contents(path)
  if not result then
    return result, message
  end
  return brigid.json.parse(result)
end

local function stringify_json(data)
  return tostring(brigid.data_writer():write_json(data))
end

----------------------------------------------------------------------

local class = {}
local metatable = { __index = class }

function class.new(config)
  local self = setmetatable({ config = config }, metatable)
  self.http_session = brigid.http_session {
    header = function (code, header)
      self.response.code = code
      self.response.header = header
    end;
    write = function (out)
      self.response.data_writer:write(out)
    end;
  }
  return self
end

function class:debug(...)
  if self.config.debug then
    print(...)
  end
end

function class:make_header(source, content_type)
  local result = {
    ["User-Agent"] = self.config.ua;
    ["Content-Type"] = content_type;
  }
  for k, v in pairs(source) do
    result[k] = v
  end
  return result
end

function class:request(method, url, header, data)
  self.response = { data_writer = brigid.data_writer() }

  local result, message = self.http_session:request {
    method = method;
    url = url;
    header = header;
    data = data;
  }
  if not result then
    return result, message
  end

  if self.config.debug then
    self:debug(stringify_json(self.response))
  end

  return self.response
end

----------------------------------------------------------------------

local commands = {}

function commands:create_session(name)
  local cred = assert(self.config.bsky.credentials[name])
end

function commands:slack(name, channel, username, iconname)
  local app = assert(self.config.slack.apps[name])
  local text = io.read "*a"

  assert(self:request("POST", "https://slack.com/api/chat.postMessage", self:make_header({
    Authorization = "Bearer "..app.oauth_token;
  }, media_types.json), stringify_json {
    token = app.oauth_token;
    channel = assert(channel);
    text = text;
    username = username;
    icon_url = self.config.icons[iconname];
  }))
end

----------------------------------------------------------------------

local home = os.getenv "HOME"
if not home then
  -- Windowsã®å ´åˆ
  home = assert(os.getenv "HOMEDRIVE")..assert(os.getenv "HOMEPATH")
end
local config_path = home.."/.csn7rc"
local config = read_json(config_path) or {}

if not config.data_dirpath then
  config.data_dirpath = home.."/.csn7"
end
brigid.mkdir(config.data_dirpath)

local self = class.new(config)

----------------------------------------------------------------------

local command = assert(commands[arg[1]])
command(self, unpack(arg, 2))

--[[


local unpack = table.unpack or unpack

local homedir = os.getenv "HOME"
local datadir = homedir.."/.brigid-atproto"


local commands = {}

-- https://atproto.com/specs/handle
function commands.save_credentials(identifier, password)




end




local brigid_atproto = require "brigid.atproto"


local IDENTIFIER, PASSWORD = ...

local text = "ç©ºãå®¶ã‹ã‚‰ã‚‚ã‚Œã ã—ã¦ã€æš—æ¸ ã‚’ä¾µé£Ÿã™ã‚‹æœ¨ã€…ã€‚ç”¨è³€ä¸­å­¦æ ¡ã®åŒ—è¥¿ã®äº¤å·®ç‚¹ã€çŸ¢æ²¢å·ã¯ä¸å­—ã«åˆæµã™ã‚‹ã€‚æµã‚Œã¯ã„ã¤ã‹ã€ç­‰ã€…åŠ›æ¸“è°·ã«è‡³ã‚‹ã€‚"

-- local text = "å…¬å¼ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã§URLã˜ã‚ƒãªã„ãƒªãƒ³ã‚¯ã‚’å¼µã‚‹æ–¹æ³•ãŒã‚ã‹ã‚‰ãªã„ã€‚ç§ã¯ç…™äººè¨ˆç”»ğŸ¤–ã€URLãƒªãƒ³ã‚¯ã¨é•ã£ã¦ãƒ¯ãƒ³ã‚¯ãƒƒã‚·ãƒ§ãƒ³å…¥ã‚‹ã€‚"
-- local i, j = assert(text:find "ç…™äººè¨ˆç”»")
-- local facets = {
--   {
--     index = {
--       byteStart = i - 1;
--       byteEnd = j;
--     };
--     features = {
--       {
--         ["$type"] = "app.bsky.richtext.facet#link";
--         uri = "https://vaporoid.com/";
--       };
--     };
--   };
-- }

local function load_blob(path)
  local handle = assert(io.open(path, "rb"))
  local data = handle:read "*a"
  handle:close()
  return data
end

local photo_path = "/Users/moyu/Desktop/photo.jpg"
local map_path = "/Users/moyu/Desktop/map.jpg"

local photo_data = load_blob(photo_path)
local map_data = load_blob(map_path)

print(#photo_data)
print(#map_data)

local atproto <close> = brigid_atproto("https://bsky.social", "brigid-atproto/0.1")
atproto.debug = true
if not atproto:load_session(IDENTIFIER) then
  assert(atproto:create_session(IDENTIFIER, PASSWORD))
end

-- assert(atproto:get("app.bsky.feed.getTimeline", { limit = 1 }))

local photo = assert(atproto:post_blob("com.atproto.repo.uploadBlob", "image/jpeg", photo_data))
local map = assert(atproto:post_blob("com.atproto.repo.uploadBlob", "image/jpeg", map_data))

assert(atproto:post("com.atproto.repo.createRecord", {
  repo = IDENTIFIER;
  collection = "app.bsky.feed.post";
  record = {
    ["$type"] = "app.bsky.feed.post";
    text = text;
    createdAt = os.date("!%Y-%m-%dT%H:%M:%SZ");
    embed = {
      ["$type"] = "app.bsky.embed.images";
      images = {
        {
          alt = "ç©ºãå®¶ã‹ã‚‰ã‚‚ã‚Œã ã—ã¦ã€æš—æ¸ ã‚’ä¾µé£Ÿã™ã‚‹æœ¨ã€…ã€‚";
          image = photo.blob;
        };
        {
          alt = "ç”¨è³€ä¸­å­¦æ ¡ã®åŒ—è¥¿ã®äº¤å·®ç‚¹ã€çŸ¢æ²¢å·ã¯ä¸å­—ã«åˆæµã™ã‚‹ã€‚";
          image = map.blob;
        };
      };
    };
  };
}))

-- assert(atproto:refresh_session())
assert(atproto:delete_session())
]]
